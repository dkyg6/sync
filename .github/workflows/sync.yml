name: Sync Upstream Releases

on:
  schedule:
    - cron: '0 * * * *'
  workflow_dispatch:
    inputs:
      repositories:
        description: '要同步的仓库列表 (格式: owner/repo, 多个用逗号分隔)'
        required: true
        default: 'AlistGo/alist,immortalwrt/immortalwrt,XTLS/Xray-core'

jobs:
  sync-releases:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    env:
      TARGET_REPO: "${{ github.repository }}"

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y curl jq git zip
          curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg | sudo dd of=/usr/share/keyrings/githubcli-archive-keyring.gpg
          sudo chmod go+r /usr/share/keyrings/githubcli-archive-keyring.gpg
          echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" | sudo tee /etc/apt/sources.list.d/github-cli.list > /dev/null
          sudo apt update
          sudo apt install -y gh

      - name: Determine repositories
        id: set-repos
        run: |
          if [ -n "${{ github.event.inputs.repositories }}" ]; then
            REPOSITORIES="${{ github.event.inputs.repositories }}"
          elif [ -n "${{ vars.UPSTREAM_REPOSITORIES }}" ]; then
            REPOSITORIES="${{ vars.UPSTREAM_REPOSITORIES }}"
          else
            REPOSITORIES="AlistGo/alist"
          fi
          echo "REPOSITORIES=${REPOSITORIES}" >> $GITHUB_OUTPUT

      - name: Process repositories
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail
          mkdir -p sync-history

          echo "${{ steps.set-repos.outputs.REPOSITORIES }}" | tr ',' '\n' | while read -r upstream_repo; do
            owner=$(cut -d/ -f1 <<< "$upstream_repo")
            repo_name=$(cut -d/ -f2 <<< "$upstream_repo")
            history_file="sync-history/${owner}_${repo_name}.txt"

            # 获取最新正式 Release
            release_response=$(curl -sL \
              -H "Accept: application/vnd.github+json" \
              -H "Authorization: Bearer ${{ github.token }}" \
              -H "X-GitHub-Api-Version: 2022-11-28" \
              "https://api.github.com/repos/$upstream_repo/releases/latest")

            # 解析 Release 信息
            tag_name=$(jq -r '.tag_name' <<< "$release_response")
            is_prerelease=$(jq -r '.prerelease' <<< "$release_response")

            # 处理未找到正式 Release 的情况
            if [[ "$tag_name" == "null" || "$is_prerelease" == "true" ]]; then
              echo "未找到正式 Release，获取最新 Tag..."
              
              # 使用 Git 获取按时间排序的最新 Tag
              git clone --quiet "https://github.com/$upstream_repo.git" temp-repo
              pushd temp-repo >/dev/null
              tag_name=$(git for-each-ref --sort=-creatordate --format '%(refname:short)' refs/tags | head -n1)
              popd >/dev/null
              rm -rf temp-repo
              
              [[ -z "$tag_name" ]] && { echo "无法获取 Tag 信息"; continue; }
            fi

            # 检查同步历史
            last_synced=$(cat "$history_file" 2>/dev/null || echo "init")
            [[ "$tag_name" == "$last_synced" ]] && continue

            # 三阶段源码获取
            download_success=false
            if [[ "$tag_name" != "null" ]]; then
              # 方式1: 从 Release 获取
              if wget -q -O "${repo_name}-${tag_name}.zip" \
                "https://github.com/$upstream_repo/archive/refs/tags/$tag_name.zip"; then
                download_success=true
              else
                # 方式2: 构造源码包 URL
                if wget -q -O "${repo_name}-${tag_name}.zip" \
                  "https://codeload.github.com/$upstream_repo/zip/refs/tags/$tag_name"; then
                  download_success=true
                else
                  # 方式3: 克隆仓库打包
                  echo "使用 Git 克隆标签 $tag_name..."
                  git clone --depth 1 --branch "$tag_name" "https://github.com/$upstream_repo.git" "${repo_name}-${tag_name}-src"
                  pushd "${repo_name}-${tag_name}-src" >/dev/null
                  zip -qr "../${repo_name}-${tag_name}.zip" .
                  popd >/dev/null
                  rm -rf "${repo_name}-${tag_name}-src"
                  download_success=true
                fi
              fi
            fi

            # 生成同步元数据
            timestamp=$(date -u +"%Y-%m-%d-%s")
            sync_tag="release-${timestamp}"
            md5_sum=$(md5sum "${repo_name}-${tag_name}.zip" | awk '{ print $1 }')

            # 创建 Release
            gh release create "$sync_tag" "${repo_name}-${tag_name}.zip" \
              --title "${timestamp}: ${repo_name} (${tag_name})" \
              --notes "MD5: ${md5_sum}\nRepo: ${upstream_repo}\nSource Tag: ${tag_name}"

            # 记录同步历史
            echo "$tag_name" > "$history_file"
            rm -f "${repo_name}-${tag_name}.zip"
          done

      - name: Commit sync history
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          git config --global user.name "GitHub Actions"
          git config --global user.email "actions@github.com"
          git add sync-history
          git commit -m "Update sync records" || exit 0
          git push
